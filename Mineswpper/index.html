<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Minesweeper â€” Play in Browser</title>
<style>
  :root{
    --bg:#1e1f26; --panel:#2b2e3a; --cell:#3a3d4a; --accent:#f6b26b; --text:#e6e7ea;
    --win:#6bbf6b; --lose:#bf6b6b;
  }
  *{box-sizing:border-box}
  body{
    margin:0; font-family:Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
    background:linear-gradient(180deg,#0f1114, #14161a); color:var(--text); min-height:100vh;
    display:flex; align-items:center; justify-content:center; padding:20px;
  }
  .wrap{width:100%; max-width:900px}
  header{display:flex; gap:12px; align-items:center; margin-bottom:14px;}
  h1{font-size:20px; margin:0; letter-spacing:0.3px}
  .controls{margin-left:auto; display:flex; gap:8px; align-items:center;}
  select,input[type=number]{padding:6px 8px; border-radius:6px; border:0; background:var(--panel); color:var(--text)}
  button{padding:8px 12px; border-radius:8px; border:0; background:var(--accent); color:#111; cursor:pointer}
  .game-panel{background:var(--panel); border-radius:12px; padding:14px; display:grid; gap:12px}
  .info{display:flex; gap:12px; align-items:center; justify-content:space-between}
  .info > div{display:flex; gap:8px; align-items:center}
  .counter{background:#14151a; padding:8px 12px; border-radius:8px; min-width:92px; text-align:center; font-weight:600}
  .status{padding:8px 12px; border-radius:8px;}
  .grid-wrap{background:transparent; display:flex; justify-content:center}
  .grid{display:grid; gap:4px; padding:12px; border-radius:8px; background:linear-gradient(180deg, rgba(255,255,255,0.02), transparent)}
  .cell{
    width:36px; height:36px; display:flex; align-items:center; justify-content:center;
    background:var(--cell); border-radius:6px; font-weight:700; font-size:16px; color:var(--text);
    user-select:none; cursor:pointer; box-shadow: 0 2px 0 rgba(0,0,0,0.35) inset;
  }
  .cell.revealed{background:linear-gradient(180deg,#dfe3e8,#c8cdd3); color:#111; box-shadow:none; cursor:default}
  .cell.mine{background:linear-gradient(180deg,#ffd6d6,#ffb7b7); color:#4a0707}
  .cell.flag{background:linear-gradient(180deg,#fef3c7,#fdeaa1); color:#714b00}
  .cell.num-1{color:#2b6cff}
  .cell.num-2{color:#138a36}
  .cell.num-3{color:#e43f3f}
  .cell.num-4{color:#2b2a86}
  .cell.num-5{color:#7a2b2b}
  .footer{display:flex; justify-content:space-between; gap:8px; align-items:center; margin-top:6px; font-size:13px}
  .hint{opacity:0.85}
  @media (max-width:520px){
    .cell{width:28px;height:28px;font-size:14px}
    .counter{min-width:70px}
  }
</style>
</head>
<body>
<div class="wrap">
  <header>
    <h1>Minesweeper</h1>
    <div class="controls">
      <label><select id="preset">
        <option value="beginner">Beginner 9Ã—9 (10)</option>
        <option value="intermediate">Intermediate 16Ã—16 (40)</option>
        <option value="expert">Expert 30Ã—16 (99)</option>
        <option value="custom">Custom</option>
      </select></label>
      <label id="customControls" style="display:none">
        W: <input id="width" type="number" min="5" max="40" value="9" style="width:64px">
        H: <input id="height" type="number" min="5" max="24" value="9" style="width:64px">
        Mines: <input id="mines" type="number" min="1" max="300" value="10" style="width:80px">
      </label>
      <button id="resetBtn">New Game</button>
    </div>
  </header>

  <section class="game-panel" id="gamePanel">
    <div class="info">
      <div>
        <div class="counter" id="minesRemain">Mines: 0</div>
        <div class="counter" id="timer">Time: 0s</div>
      </div>
      <div class="status" id="statusLabel">Ready</div>
    </div>

    <div class="grid-wrap">
      <div id="grid" class="grid" role="grid" aria-label="Minesweeper grid"></div>
    </div>

    <div class="footer">
      <div class="hint">Left-click reveal â€¢ Right-click flag â€¢ On touch: long-press to flag</div>
      <div>Made for you â€” save as <code>minesweeper.html</code> and open in a browser</div>
    </div>
  </section>
</div>

<script>
(() => {
  // --- State ---
  let W = 9, H = 9, MINES = 10;
  let gridEl = document.getElementById('grid');
  let minesRemainEl = document.getElementById('minesRemain');
  let timerEl = document.getElementById('timer');
  let statusEl = document.getElementById('statusLabel');
  let resetBtn = document.getElementById('resetBtn');
  let preset = document.getElementById('preset');
  let customControls = document.getElementById('customControls');
  let widthInput = document.getElementById('width');
  let heightInput = document.getElementById('height');
  let minesInput = document.getElementById('mines');

  let cells = []; // objects {el, x, y, isMine, revealed, flagged, neigh}
  let started = false, timer = null, time = 0;
  let remainingFlags = 0;
  let gameOver = false;
  let longPressTimer = null;

  // --- Helpers ---
  function coordToIndex(x,y){ return y*W + x; }
  function inBounds(x,y){ return x>=0 && y>=0 && x<W && y<H; }

  function createGrid(){
    gridEl.innerHTML = '';
    gridEl.style.gridTemplateColumns = `repeat(${W}, auto)`;
    gridEl.style.gridTemplateRows = `repeat(${H}, auto)`;
    cells = [];
    for(let y=0;y<H;y++){
      for(let x=0;x<W;x++){
        let el = document.createElement('div');
        el.className = 'cell';
        el.dataset.x = x; el.dataset.y = y;
        el.tabIndex = 0;
        el.oncontextmenu = (e)=>e.preventDefault();
        gridEl.appendChild(el);
        cells.push({el,x,y,isMine:false,revealed:false,flagged:false,neigh:0});
      }
    }
    remainingFlags = MINES;
    updateCounters();
    setStatus('Ready');
    resetTimer();
    gameOver = false;
  }

  function randomInt(max){ return Math.floor(Math.random()*max); }

  function plantMines(firstX, firstY){
    // plant MINES mines, but never on first click and neighbors of first click
    let forbidden = new Set();
    for(let dy=-1;dy<=1;dy++){
      for(let dx=-1;dx<=1;dx++){
        let nx=firstX+dx, ny=firstY+dy;
        if(inBounds(nx,ny)) forbidden.add(coordToIndex(nx,ny));
      }
    }
    let planted = 0;
    while(planted < MINES){
      let idx = randomInt(W*H);
      if(forbidden.has(idx)) continue;
      if(cells[idx].isMine) continue;
      cells[idx].isMine = true;
      planted++;
    }
    // compute neighbor counts
    for(let cell of cells){
      let count = 0;
      for(let dy=-1;dy<=1;dy++){
        for(let dx=-1;dx<=1;dx++){
          if(dx===0 && dy===0) continue;
          let nx=cell.x+dx, ny=cell.y+dy;
          if(inBounds(nx,ny) && cells[coordToIndex(nx,ny)].isMine) count++;
        }
      }
      cell.neigh = count;
    }
  }

  function revealCell(cell, chain=true){
    if(gameOver || cell.revealed || cell.flagged) return;
    cell.revealed = true;
    cell.el.classList.add('revealed');
    if(cell.isMine){
      cell.el.classList.add('mine');
      cell.el.textContent = 'ðŸ’£';
      // end game lose
      endGame(false);
      return;
    }
    if(cell.neigh>0){
      cell.el.classList.add('num-'+cell.neigh);
      cell.el.textContent = cell.neigh;
    } else {
      cell.el.textContent = '';
      // flood fill neighbors
      if(chain){
        for(let dy=-1;dy<=1;dy++){
          for(let dx=-1;dx<=1;dx++){
            if(dx===0 && dy===0) continue;
            let nx=cell.x+dx, ny=cell.y+dy;
            if(inBounds(nx,ny)){
              revealCell(cells[coordToIndex(nx,ny)], true);
            }
          }
        }
      }
    }
    checkWin();
  }

  function revealSurrounding(cell){
    // reveal neighbors only if number of flags around equals neigh
    let flags = 0;
    let neighbors = [];
    for(let dy=-1;dy<=1;dy++){
      for(let dx=-1;dx<=1;dx++){
        if(dx===0 && dy===0) continue;
        let nx=cell.x+dx, ny=cell.y+dy;
        if(inBounds(nx,ny)){
          let n = cells[coordToIndex(nx,ny)];
          neighbors.push(n);
          if(n.flagged) flags++;
        }
      }
    }
    if(flags === cell.neigh){
      for(let n of neighbors) revealCell(n, true);
    }
  }

  function toggleFlag(cell){
    if(gameOver || cell.revealed) return;
    cell.flagged = !cell.flagged;
    cell.el.classList.toggle('flag', cell.flagged);
    cell.el.textContent = cell.flagged ? 'ðŸš©' : '';
    remainingFlags += cell.flagged ? -1 : 1;
    updateCounters();
    checkWin();
  }

  function updateCounters(){
    minesRemainEl.textContent = `Mines: ${remainingFlags}`;
  }

  function resetTimer(){
    clearInterval(timer);
    time = 0;
    timerEl.textContent = `Time: 0s`;
    started = false;
  }
  function startTimer(){
    if(started) return;
    started = true;
    timer = setInterval(()=>{
      time++;
      timerEl.textContent = `Time: ${time}s`;
    },1000);
  }

  function setStatus(text, color=null){
    statusEl.textContent = text;
    statusEl.style.background = color ? color : 'transparent';
  }

  function endGame(win){
    gameOver = true;
    clearInterval(timer);
    // reveal all mines if lose
    if(!win){
      for(let c of cells){
        if(c.isMine && !c.flagged){
          c.revealed = true;
          c.el.classList.add('revealed','mine');
          c.el.textContent = 'ðŸ’£';
        }
        if(!c.isMine && c.flagged){
          c.el.textContent = 'âœ–';
          c.el.style.opacity = 0.7;
        }
      }
      setStatus('You Lost ðŸ’¥', 'var(--lose)');
    } else {
      setStatus('You Win ðŸŽ‰', 'var(--win)');
    }
  }

  function checkWin(){
    if(gameOver) return;
    // win when all non-mine cells revealed OR all mines flagged correctly.
    let allClear = true;
    for(let c of cells){
      if(!c.isMine && !c.revealed) { allClear = false; break; }
    }
    if(allClear){
      endGame(true);
      return;
    }
    // alternative: if number of flagged equals mines and all flags on mines
    let flaggedCount = cells.filter(c=>c.flagged).length;
    if(flaggedCount === MINES){
      let correct = cells.every(c => !c.flagged || c.isMine);
      if(correct) endGame(true);
    }
  }

  // --- Event wiring ---
  function attachEvents(){
    // mouse & keyboard events
    gridEl.addEventListener('mousedown', (e)=>{
      let target = e.target.closest('.cell');
      if(!target) return;
      let idx = coordToIndex(+target.dataset.x, +target.dataset.y);
      let cell = cells[idx];

      // left-click (button 0) or right-click (2)
      if(e.button === 2){
        toggleFlag(cell);
      } else if(e.button === 0){
        // start timer on first reveal and plant mines
        if(!started && !gameOver){
          plantMines(cell.x, cell.y);
          startTimer();
        }
        // left click reveals
        if(cell.revealed && cell.neigh>0){
          // pressing on revealed number and using neighbor reveal
          revealSurrounding(cell);
        } else {
          revealCell(cell);
        }
      }
    });

    // contextmenu to flag with right click neatly
    gridEl.addEventListener('contextmenu', (e)=>{
      e.preventDefault();
      let target = e.target.closest('.cell');
      if(!target) return;
      let idx = coordToIndex(+target.dataset.x, +target.dataset.y);
      toggleFlag(cells[idx]);
    });

    // keyboard: Enter/Space reveal, 'F' flag
    gridEl.addEventListener('keydown', (e)=>{
      if(e.key === ' ' || e.key === 'Enter'){
        e.preventDefault();
        let target = e.target.closest('.cell');
        if(!target) return;
        let idx = coordToIndex(+target.dataset.x, +target.dataset.y);
        let cell = cells[idx];
        if(!started && !gameOver){
          plantMines(cell.x, cell.y);
          startTimer();
        }
        if(cell.revealed && cell.neigh>0){
          revealSurrounding(cell);
        } else {
          revealCell(cell);
        }
      } else if(e.key.toLowerCase() === 'f'){
        e.preventDefault();
        let target = e.target.closest('.cell');
        if(!target) return;
        toggleFlag(cells[coordToIndex(+target.dataset.x, +target.dataset.y)]);
      }
    });

    // mobile long-press to flag
    gridEl.addEventListener('touchstart', (e)=>{
      if(e.touches.length>1) return;
      let target = e.target.closest('.cell');
      if(!target) return;
      longPressTimer = setTimeout(()=>{
        let idx = coordToIndex(+target.dataset.x, +target.dataset.y);
        toggleFlag(cells[idx]);
      }, 450);
    });
    gridEl.addEventListener('touchend', (e)=>{
      clearTimeout(longPressTimer);
    });
    gridEl.addEventListener('touchmove', (e)=>{
      clearTimeout(longPressTimer);
    });

    // reset button
    resetBtn.addEventListener('click', ()=>{
      initFromUI();
    });

    preset.addEventListener('change', ()=>{
      if(preset.value === 'custom') customControls.style.display = 'inline-flex';
      else customControls.style.display = 'none';
      applyPreset();
    });

    widthInput.addEventListener('change', applyPreset);
    heightInput.addEventListener('change', applyPreset);
    minesInput.addEventListener('change', applyPreset);
  }

  function applyPreset(){
    let p = preset.value;
    if(p === 'beginner'){ W=9; H=9; MINES=10; }
    else if(p === 'intermediate'){ W=16; H=16; MINES=40; }
    else if(p === 'expert'){ W=30; H=16; MINES=99; }
    else {
      W = Math.max(5, Math.min(40, parseInt(widthInput.value)||9));
      H = Math.max(5, Math.min(24, parseInt(heightInput.value)||9));
      MINES = Math.max(1, Math.min(W*H-1, parseInt(minesInput.value)||10));
    }
    // reflect custom inputs
    widthInput.value = W; heightInput.value = H; minesInput.value = MINES;
    createGrid();
  }

  function initFromUI(){
    applyPreset();
    setStatus('Ready');
  }

  // initialize
  createGrid();
  attachEvents();

  // prevent dragging text
  document.addEventListener('dragstart', e=>e.preventDefault());

  // focus first cell for keyboard
  gridEl.addEventListener('click', (e)=>{
    let target = e.target.closest('.cell');
    if(target) target.focus();
  });

  // set initial UI values
  function setStatus(text){ statusEl.textContent = text; }
  // update mines label
  function updateCounters(){ minesRemainEl.textContent = `Mines: ${remainingFlags}`; }

  // make sure we call apply preset to set initial state
  preset.value = 'beginner';
  applyPreset();

  // expose a bit for debugging in console (optional)
  window._minesweeper = {cells, newGame: initFromUI};
})();
</script>
</body>
</html>
